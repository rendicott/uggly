# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: uggly.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import AsyncGenerator, List

import betterproto
import grpclib


class CookieSameSite(betterproto.Enum):
    STRICT = 0
    NONE = 1


@dataclass
class Pixel(betterproto.Message):
    """
    Pixel can be used in RawContents. Could be honored for use cases such as
    animations or gaming.
    """

    c: int = betterproto.int32_field(10)
    st: "Style" = betterproto.message_field(11)
    is_border: bool = betterproto.bool_field(12)


@dataclass
class DivBox(betterproto.Message):
    """
    DivBox is a core element of the protocol. No content can existoutside of a
    DivBox. It requires that some basic properties are includedsuch as fill and
    border geometry but the rawContents property is opento fill with whatever
    content is desired.
    """

    name: str = betterproto.string_field(9)
    border: bool = betterproto.bool_field(10)
    border_w: int = betterproto.int32_field(11)
    border_char: int = betterproto.int32_field(12)
    fill_char: int = betterproto.int32_field(14)
    start_x: int = betterproto.int32_field(15)
    start_y: int = betterproto.int32_field(16)
    width: int = betterproto.int32_field(17)
    height: int = betterproto.int32_field(18)
    pixels: List["Pixel"] = betterproto.message_field(19)
    border_st: "Style" = betterproto.message_field(20)
    fill_st: "Style" = betterproto.message_field(21)


@dataclass
class TextBlob(betterproto.Message):
    """
    TextBlob is a special kind of element that natively understandstext blocks
    intended for human readability. Obviously it has a contentproperty but also
    understands things like text style and text wrap when the text is larger
    than the width of the container it was assigned to. A TextBlob can be
    assigned to multiple Divs in case you wanted to re-usetext in multiple
    places for some reason.
    """

    content: str = betterproto.string_field(10)
    wrap: bool = betterproto.bool_field(11)
    style: "Style" = betterproto.message_field(12)
    div_names: List[str] = betterproto.string_field(15)


@dataclass
class DivBoxes(betterproto.Message):
    """DivBoxes is an array of DivBox"""

    boxes: List["DivBox"] = betterproto.message_field(10)


@dataclass
class Style(betterproto.Message):
    """
    Style is a base property used in divBox fill, border fill, and
    textboxeswith fg being foreground color, bg being background color, and
    attrbeing text attributes like strikethrough and underline.It's essentially
    a passthrough of the capabilities of tcell's
    stylehttps://github.com/gdamore/tcell/blob/master/style.go
    """

    fg: str = betterproto.string_field(10)
    bg: str = betterproto.string_field(11)
    attr: str = betterproto.string_field(12)


@dataclass
class Link(betterproto.Message):
    """
    Link contains information about keyboard shortcuts and destinations for
    actions. The client will determine from context whether a Link is to a
    server page or is  to be used to pass polling context to a Form that it
    already receieved in a PageResponse.
    """

    key_stroke: str = betterproto.string_field(10)
    page_name: str = betterproto.string_field(11)
    server: str = betterproto.string_field(12)
    port: str = betterproto.string_field(13)
    secure: bool = betterproto.bool_field(16)
    stream: bool = betterproto.bool_field(17)


@dataclass
class DivScroll(betterproto.Message):
    div_name: str = betterproto.string_field(10)
    down: bool = betterproto.bool_field(11)


@dataclass
class FormActivation(betterproto.Message):
    form_name: str = betterproto.string_field(10)


@dataclass
class KeyStroke(betterproto.Message):
    key_stroke: str = betterproto.string_field(10)
    link: "Link" = betterproto.message_field(20, group="Action")
    div_scroll: "DivScroll" = betterproto.message_field(21, group="Action")
    form_activation: "FormActivation" = betterproto.message_field(22, group="Action")


@dataclass
class TextBox(betterproto.Message):
    """
    TextBox contains the properties sent by the server for the client to
    render.
    """

    name: str = betterproto.string_field(10)
    tab_order: int = betterproto.int32_field(11)
    default_value: str = betterproto.string_field(12)
    description: str = betterproto.string_field(13)
    position_x: int = betterproto.int32_field(14)
    position_y: int = betterproto.int32_field(15)
    height: int = betterproto.int32_field(16)
    width: int = betterproto.int32_field(17)
    style_cursor: "Style" = betterproto.message_field(18)
    style_fill: "Style" = betterproto.message_field(19)
    style_text: "Style" = betterproto.message_field(20)
    style_description: "Style" = betterproto.message_field(21)
    show_description: bool = betterproto.bool_field(22)
    password: bool = betterproto.bool_field(23)


@dataclass
class Form(betterproto.Message):
    """
    The Form is sent by the server to the client as part of the PageResponse.
    It contains the Form name, the DivBox it should be placed within (TextBox
    PositionX and Y coordinates are relative to the containing DivBox) and a
    list of the TextBox's included in this form. It also supports a parameter
    for a Link that can be used as a return address when this Form is
    submitted in a PageRequest
    """

    name: str = betterproto.string_field(10)
    div_name: str = betterproto.string_field(11)
    text_boxes: List["TextBox"] = betterproto.message_field(12)
    submit_link: "Link" = betterproto.message_field(13)


@dataclass
class FormData(betterproto.Message):
    """
    FormData contains the form name and any TextBoxData that was in the form
    when the FormData was sent in the PageRequest
    """

    name: str = betterproto.string_field(10)
    text_box_data: List["TextBoxData"] = betterproto.message_field(11)


@dataclass
class TextBoxData(betterproto.Message):
    """
    TextBoxData contains the text box's field name and whatever contents were
    in it when the PageRequest was sent with FormData
    """

    name: str = betterproto.string_field(10)
    contents: str = betterproto.string_field(11)


@dataclass
class Elements(betterproto.Message):
    """
    Elements contains all non-DivBox related content that could be included in
    a PageResponse. Right now this contains TextBlobs and Forms but will be
    used for future elements if needed.  For example, if determined that
    clients should handle all Table rendering in the future or something. Right
    now tables would have to be stick built by  the server using DivBoxes and
    TextBlobs
    """

    text_blobs: List["TextBlob"] = betterproto.message_field(10)
    forms: List["Form"] = betterproto.message_field(11)


@dataclass
class PageListing(betterproto.Message):
    """
    A PageListing is basically a key/value pair of page name and an optional
    description. The client can choose to render this however it wants and the
    client injects it's own "links" to this content. This is a lazy way of
    exposing all the server's content without having to build nav menus and
    manage links
    """

    name: str = betterproto.string_field(10)
    description: str = betterproto.string_field(11)


@dataclass
class PageResponse(betterproto.Message):
    """
    The PageResponse contains modular content that the server wishes the client
    to display in the form of DivBoxes, Elements, and Links.
    """

    div_boxes: "DivBoxes" = betterproto.message_field(10)
    elements: "Elements" = betterproto.message_field(11)
    name: str = betterproto.string_field(12)
    key_strokes: List["KeyStroke"] = betterproto.message_field(13)
    set_cookies: List["Cookie"] = betterproto.message_field(14)
    # if the response is part of a stream then this is the time in milliseconds
    # the client should wait  before drawing the next request
    stream_delay_ms: int = betterproto.int32_field(15)


@dataclass
class Cookie(betterproto.Message):
    """
    Cookie loosly follows the cookie spec (https://developer.mozilla.org/en-
    US/docs/Web/HTTP/Headers/Set-Cookie) but does not include protections for
    browser side code as today the uggly spec does not support client side
    code.
    """

    key: str = betterproto.string_field(10)
    value: str = betterproto.string_field(11)
    # the server which requested this cookie to be set.  should be server only
    # without including port e.g., "localhost" or "mysubdomain.domain.com"
    server: str = betterproto.string_field(12)
    # private Cookies will never be sent back to server
    private: bool = betterproto.bool_field(13)
    # date when cookie expires relative to client in RFC1123 format.  If
    # improperly formatted will just be ignored and cookie will be treated as
    # session cookie.
    expires: str = betterproto.string_field(14)
    same_site: "CookieSameSite" = betterproto.enum_field(15)
    page: str = betterproto.string_field(16)
    secure: bool = betterproto.bool_field(17)
    # indicates that this cookie should be sent in header metadata instead of
    # body.  This is useful if the server wants to pre-filter traffic, for
    # example if a request is not authenticated it can avoid processing the full
    # PageRequest
    metadata: bool = betterproto.bool_field(18)


@dataclass
class PageRequest(betterproto.Message):
    """
    A PageRequest contains the name of the  desired page and some metadata
    about the cient height and width. The server can choose to ignore the width
    and height if it insists  on statically sized content. Also, the server
    could generate a PageResponse saying something like  "this server insists
    on a minimum height to view content" for example.  Also included is any
    FormData the client wishes to send with this PageRequest.
    """

    name: str = betterproto.string_field(10)
    client_width: int = betterproto.int32_field(11)
    client_height: int = betterproto.int32_field(12)
    form_data: List["FormData"] = betterproto.message_field(13)
    server: str = betterproto.string_field(14)
    port: str = betterproto.string_field(15)
    secure: bool = betterproto.bool_field(16)
    send_cookies: List["Cookie"] = betterproto.message_field(17)
    stream: bool = betterproto.bool_field(18)


@dataclass
class FeedResponse(betterproto.Message):
    """
    A FeedResponse is essentially a list of  Pages that the server wishes to
    expose to the client. The server can obviously choose to hide some Pages or
    if it generates Pages dynamically it may not even be able to provide an
    accurate listing.
    """

    pages: List["PageListing"] = betterproto.message_field(10)
    notes: str = betterproto.string_field(11)


@dataclass
class FeedRequest(betterproto.Message):
    """
    A FeedRequest really needs no properties as it's just a call from the
    client for the server to send a Feed if it has one.
    """

    send_data: bool = betterproto.bool_field(10)


class FeedStub(betterproto.ServiceStub):
    """
    Feed service can be implemented by the server and must provide a
    FeedResponse for a given FeedRequest. This is to be used as somewhat of a
    server index of  available Pages when the server chooses to implement. It
    is strongly encouraged to implement a Feed because it makes for quality of
    life improvements for the client's user
    """

    async def get_feed(self, *, send_data: bool = False) -> FeedResponse:
        request = FeedRequest()
        request.send_data = send_data

        return await self._unary_unary(
            "/uggly.Feed/GetFeed",
            request,
            FeedResponse,
        )


class PageStub(betterproto.ServiceStub):
    """
    In order for a server to serve any content it must  implement the Page
    service which returns PageResponse for a given PageRequest
    """

    async def get_page(
        self,
        *,
        name: str = "",
        client_width: int = 0,
        client_height: int = 0,
        form_data: List["FormData"] = [],
        server: str = "",
        port: str = "",
        secure: bool = False,
        send_cookies: List["Cookie"] = [],
        stream: bool = False,
    ) -> PageResponse:
        request = PageRequest()
        request.name = name
        request.client_width = client_width
        request.client_height = client_height
        if form_data is not None:
            request.form_data = form_data
        request.server = server
        request.port = port
        request.secure = secure
        if send_cookies is not None:
            request.send_cookies = send_cookies
        request.stream = stream

        return await self._unary_unary(
            "/uggly.Page/GetPage",
            request,
            PageResponse,
        )

    async def get_page_stream(
        self,
        *,
        name: str = "",
        client_width: int = 0,
        client_height: int = 0,
        form_data: List["FormData"] = [],
        server: str = "",
        port: str = "",
        secure: bool = False,
        send_cookies: List["Cookie"] = [],
        stream: bool = False,
    ) -> AsyncGenerator[PageResponse, None]:
        request = PageRequest()
        request.name = name
        request.client_width = client_width
        request.client_height = client_height
        if form_data is not None:
            request.form_data = form_data
        request.server = server
        request.port = port
        request.secure = secure
        if send_cookies is not None:
            request.send_cookies = send_cookies
        request.stream = stream

        async for response in self._unary_stream(
            "/uggly.Page/GetPageStream",
            request,
            PageResponse,
        ):
            yield response
